# Test auto position based tailing after election. After election we purge
# apply logs that make gtid_purged == gtid_executed even though all transcations
# exist in the raft log.

source ../include/raft_3_node.inc;
source include/have_debug_sync.inc;
let $use_gtids= 1;

--disable_query_log
call mtr.add_suppression(".*using --replicate-same-server-id in conjunction with --log-slave-updates.*");
--enable_query_log

# Create connections to server 4 and 5 (these are not in the ring)
let $rpl_server_number= 4;
let $rpl_connection_name= server_4;
source include/rpl_connect.inc;
--disable_query_log
connection server_4;
call mtr.add_suppression(".*using --replicate-same-server-id in conjunction with --log-slave-updates.*");
--enable_query_log

let $rpl_server_number= 5;
let $rpl_connection_name= server_5;
source include/rpl_connect.inc;
--disable_query_log
connection server_5;
call mtr.add_suppression(".*using --replicate-same-server-id in conjunction with --log-slave-updates.*");
--enable_query_log

# Execute some transactions
connection server_1;
let $uuid1= `select variable_value from performance_schema.global_status where variable_name = 'Rpl_raft_peer_uuid'`;
create table t1 (a int) engine = innodb;
insert into t1 values(1);
insert into t1 values(2);

# Trasfer leadership to server_2 (this will clear out the apply logs and make
# gtid_purged == gtid_executed
connection server_2;
let $uuid2= `select variable_value from performance_schema.global_status where variable_name = 'Rpl_raft_peer_uuid'`;
let $port2= `select @@global.port`;
connection server_1;
replace_result $uuid2 uuid2;
eval set @@global.rpl_raft_new_leader_uuid = '$uuid2';

# Make server_4 tail server_2
connection server_4;
replace_result $port2 port2;
eval change master to master_host='localhost', master_port=$port2, master_auto_position=1, master_user='root';
source include/start_slave.inc;
--let $uuid4= `SELECT @@GLOBAL.SERVER_UUID`
connection server_2;
# Note: This insert statement is required to move the last_acked to correct position.
insert into t1 values(3);
let $sync_slave_connection= server_4;
source include/sync_slave_sql_with_master.inc;

connection server_4;
select * from t1;

# Cleanup
connection server_2;
replace_result $uuid1 uuid1;
eval set @@global.rpl_raft_new_leader_uuid = '$uuid1';
connection server_1;
let $wait_condition= select @@global.read_only = 0;
source include/wait_condition.inc;
drop table t1;

let $sync_slave_connection= server_2;
source include/sync_slave_sql_with_master.inc;
let $sync_slave_connection= server_3;
source include/sync_slave_sql_with_master.inc;
let $sync_slave_connection= server_4;
source include/sync_slave_sql_with_master.inc;

connection server_4;
source include/stop_slave.inc;
reset slave all;

source include/rpl_end.inc;
